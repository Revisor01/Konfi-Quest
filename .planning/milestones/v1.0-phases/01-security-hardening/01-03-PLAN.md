---
phase: 01-security-hardening
plan: 03
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - backend/routes/auth.js
  - backend/routes/activities.js
  - backend/routes/konfi-managment.js
  - backend/routes/events.js
  - backend/routes/chat.js
  - backend/routes/notifications.js
  - backend/routes/settings.js
  - backend/routes/badges.js
  - backend/routes/jahrgaenge.js
  - backend/routes/categories.js
  - backend/routes/users.js
  - backend/routes/organizations.js
  - backend/routes/levels.js
  - backend/routes/konfi.js
  - backend/routes/roles.js
  - backend/middleware/validation.js
  - frontend/src/services/api.ts
autonomous: true
requirements: [SEC-04, SEC-05]

must_haves:
  truths:
    - "Alle Endpoints die Daten entgegennehmen haben express-validator Validierungsregeln"
    - "Validierungsfehler werden als 400 mit deutschsprachigen Feld-Fehlermeldungen zurueckgegeben"
    - "Bei 429-Rate-Limit sieht der Nutzer eine deutschsprachige Inline-Fehlermeldung mit Wartezeit"
    - "Das Frontend faengt 429-Responses global ab und stellt rateLimitMessage bereit"
  artifacts:
    - path: "backend/middleware/validation.js"
      provides: "Erweiterte Validierungs-Middleware mit wiederverwendbaren Validierungsregeln"
      exports: ["handleValidationErrors", "getPointField", "validateId", "commonValidations"]
    - path: "frontend/src/services/api.ts"
      provides: "Globaler 429-Interceptor mit rateLimitMessage"
      contains: "rateLimitMessage"
  key_links:
    - from: "backend/routes/*.js"
      to: "backend/middleware/validation.js"
      via: "require + Validierungs-Arrays als Middleware"
      pattern: "handleValidationErrors"
    - from: "frontend/src/services/api.ts"
      to: "429 Response"
      via: "axios interceptor"
      pattern: "status === 429"
---

<objective>
express-validator auf den wichtigsten Endpoints einfuehren und den 429-Rate-Limiter-Interceptor im Frontend implementieren.

Purpose: Systematische Input-Validierung verhindert ungueltige Daten und gibt dem Nutzer verstaendliche deutschsprachige Fehlermeldungen. Der 429-Interceptor verbessert die UX bei Rate-Limiting.
Output: Validierungsregeln auf den kritischsten Endpoints (auth, activities, konfi-management, events, chat), globaler 429-Interceptor im Frontend.
</objective>

<execution_context>
@/Users/simonluthe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simonluthe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-hardening/01-CONTEXT.md
@.planning/phases/01-security-hardening/01-RESEARCH.md

# Prior plan output (middleware/validation.js created in 01-01):
@.planning/phases/01-security-hardening/01-01-SUMMARY.md

@backend/middleware/validation.js
@frontend/src/services/api.ts

<interfaces>
<!-- handleValidationErrors und getPointField aus Plan 01: -->
```javascript
// backend/middleware/validation.js (erstellt in Plan 01)
const { validationResult } = require('express-validator');

const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      error: 'Validierungsfehler',
      details: errors.array().map(e => ({
        field: e.path,
        message: e.msg
      }))
    });
  }
  next();
};

const VALID_POINT_FIELDS = { gottesdienst: 'gottesdienst_points', gemeinde: 'gemeinde_points' };
function getPointField(type) { /* ... */ }

module.exports = { handleValidationErrors, getPointField };
```

<!-- Express-validator Pattern fuer Validierungsregeln: -->
```javascript
const { body, param, query } = require('express-validator');
const { handleValidationErrors } = require('../middleware/validation');

const validateCreateSomething = [
  body('name').trim().notEmpty().withMessage('Name ist erforderlich'),
  body('points').isInt({ min: 1 }).withMessage('Punkte muessen positiv sein'),
  handleValidationErrors
];

router.post('/', rbacVerifier, requireAdmin, validateCreateSomething, handler);
```

<!-- Bestehender Frontend-Interceptor: -->
```typescript
// frontend/src/services/api.ts
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      const isLoginRequest = error.config?.url?.includes('/login');
      if (!isLoginRequest) {
        localStorage.removeItem('konfi_token');
        localStorage.removeItem('konfi_user');
        window.location.href = '/';
      }
    }
    return Promise.reject(error);
  }
);
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wiederverwendbare Validierungsregeln in middleware/validation.js erweitern</name>
  <files>backend/middleware/validation.js</files>
  <action>
Die bestehende middleware/validation.js (aus Plan 01) um wiederverwendbare Validierungsbausteine erweitern.

Folgende Exports hinzufuegen (NACH den bestehenden handleValidationErrors und getPointField):

```javascript
const { body, param, query } = require('express-validator');

// Wiederverwendbar: ID-Parameter validieren
const validateId = param('id').isInt({ min: 1 }).withMessage('Ungueltige ID');

// Wiederverwendbar: Pagination-Parameter
const validatePagination = [
  query('page').optional().isInt({ min: 1 }).withMessage('Seitenzahl muss positiv sein'),
  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit muss zwischen 1 und 100 liegen')
];

// Gemeinsame Validierungen fuer haeufige Felder
const commonValidations = {
  name: body('name').trim().notEmpty().withMessage('Name ist erforderlich')
    .isLength({ min: 2, max: 100 }).withMessage('Name muss zwischen 2 und 100 Zeichen lang sein'),
  description: body('description').optional().trim()
    .isLength({ max: 500 }).withMessage('Beschreibung darf maximal 500 Zeichen lang sein'),
  points: body('points').isInt({ min: 1 }).withMessage('Punkte muessen eine positive Ganzzahl sein'),
  type: body('type').isIn(['gottesdienst', 'gemeinde']).withMessage('Typ muss "gottesdienst" oder "gemeinde" sein'),
  email: body('email').trim().isEmail().withMessage('Gueltige E-Mail-Adresse erforderlich'),
  username: body('username').trim()
    .isLength({ min: 3, max: 50 }).withMessage('Benutzername muss zwischen 3 und 50 Zeichen lang sein')
    .matches(/^[a-zA-Z0-9._-]+$/).withMessage('Benutzername darf nur Buchstaben, Zahlen, Punkte, Bindestriche und Unterstriche enthalten'),
  password: body('password')
    .isLength({ min: 6 }).withMessage('Passwort muss mindestens 6 Zeichen lang sein'),
  date: body('completed_date').optional().isISO8601().withMessage('Ungueltiges Datumsformat'),
};
```

Aktualisierte Exports:
```javascript
module.exports = {
  handleValidationErrors,
  getPointField,
  validateId,
  validatePagination,
  commonValidations
};
```

WICHTIG: Alle .withMessage()-Texte auf Deutsch (per User-Decision: feld-spezifische Validierungsfehler).
  </action>
  <verify>
    <automated>cd /Users/simonluthe/Documents/Konfipoints/backend && node -e "const v = require('./middleware/validation'); console.log('exports:', Object.keys(v).join(', ')); console.log('commonValidations keys:', Object.keys(v.commonValidations).join(', '));"</automated>
  </verify>
  <done>middleware/validation.js exportiert handleValidationErrors, getPointField, validateId, validatePagination, commonValidations. commonValidations hat mindestens name, description, points, type, email, username, password, date.</done>
</task>

<task type="auto">
  <name>Task 2: express-validator auf die kritischsten Route-Files anwenden</name>
  <files>
    backend/routes/auth.js
    backend/routes/activities.js
    backend/routes/konfi-managment.js
    backend/routes/events.js
    backend/routes/chat.js
    backend/routes/notifications.js
    backend/routes/settings.js
    backend/routes/badges.js
    backend/routes/jahrgaenge.js
    backend/routes/categories.js
    backend/routes/users.js
    backend/routes/organizations.js
    backend/routes/levels.js
    backend/routes/konfi.js
    backend/routes/roles.js
  </files>
  <action>
Auf JEDEM Route-File express-validator Validierungsregeln als Middleware-Array VOR den Route-Handlern hinzufuegen.

**Vorgehen pro Route-File:**

1. Am Anfang der Datei importieren:
   ```javascript
   const { body, param, query } = require('express-validator');
   const { handleValidationErrors, commonValidations } = require('../middleware/validation');
   ```

2. Fuer jeden POST/PUT/PATCH-Endpoint ein Validierungs-Array definieren und als Middleware einhaengen.

3. Die BESTEHENDE manuelle Validierung (z.B. `if (!name || !points) return res.status(400)...`) kann BESTEHEN BLEIBEN als Fallback -- die express-validator Middleware faengt ungueltige Daten vorher ab.

**Priorisierte Endpoints (MUESSEN validiert werden):**

**auth.js:**
- POST /login: `[body('username').trim().notEmpty().withMessage('Benutzername ist erforderlich'), body('password').notEmpty().withMessage('Passwort ist erforderlich'), handleValidationErrors]`
- POST /register: `[commonValidations.username, commonValidations.password, body('display_name').trim().notEmpty().withMessage('Anzeigename ist erforderlich'), body('invite_code').trim().notEmpty().withMessage('Einladungscode ist erforderlich'), handleValidationErrors]`
- PUT /change-password: `[body('currentPassword').notEmpty().withMessage('Aktuelles Passwort ist erforderlich'), body('newPassword').isLength({ min: 6 }).withMessage('Neues Passwort muss mindestens 6 Zeichen lang sein'), handleValidationErrors]`
- POST /forgot-password: `[commonValidations.email, handleValidationErrors]`

**activities.js:**
- POST / (create activity): `[commonValidations.name, commonValidations.points, commonValidations.type, body('category_ids').optional().isArray().withMessage('Kategorie-IDs muessen ein Array sein'), handleValidationErrors]`
- PUT /:id (update activity): `[param('id').isInt({ min: 1 }).withMessage('Ungueltige ID'), commonValidations.name, commonValidations.points, commonValidations.type, handleValidationErrors]`
- POST /assign-activity: `[body('konfiId').isInt({ min: 1 }).withMessage('Ungueltige Konfi-ID'), body('activityId').isInt({ min: 1 }).withMessage('Ungueltige Aktivitaets-ID'), commonValidations.date, handleValidationErrors]`
- POST /assign-bonus: `[body('konfiId').isInt({ min: 1 }).withMessage('Ungueltige Konfi-ID'), commonValidations.points, commonValidations.type, body('description').trim().notEmpty().withMessage('Beschreibung ist erforderlich'), commonValidations.date, handleValidationErrors]`
- PUT /requests/:id: `[param('id').isInt({ min: 1 }).withMessage('Ungueltige ID'), body('status').isIn(['approved', 'rejected']).withMessage('Status muss "approved" oder "rejected" sein'), handleValidationErrors]`

**konfi-managment.js:**
- POST /:id/bonus-points: `[param('id').isInt({ min: 1 }).withMessage('Ungueltige Konfi-ID'), commonValidations.points, commonValidations.type, body('description').trim().notEmpty().withMessage('Beschreibung ist erforderlich'), handleValidationErrors]`
- POST /:id/activities: `[param('id').isInt({ min: 1 }).withMessage('Ungueltige Konfi-ID'), body('activity_id').isInt({ min: 1 }).withMessage('Ungueltige Aktivitaets-ID'), body('completed_date').notEmpty().isISO8601().withMessage('Gueltiges Datum erforderlich'), handleValidationErrors]`

**events.js:**
- POST / (create event): `[body('title').trim().notEmpty().withMessage('Titel ist erforderlich').isLength({ max: 200 }).withMessage('Titel darf maximal 200 Zeichen lang sein'), body('date').notEmpty().isISO8601().withMessage('Gueltiges Datum erforderlich'), handleValidationErrors]`
- PUT /:id (update event): `[param('id').isInt({ min: 1 }).withMessage('Ungueltige ID'), body('title').trim().notEmpty().withMessage('Titel ist erforderlich'), handleValidationErrors]`

**chat.js:**
- POST /rooms: `[body('name').optional().trim(), body('type').isIn(['group', 'direct', 'jahrgang']).withMessage('Ungueltiger Chat-Typ'), handleValidationErrors]`
- POST /rooms/:roomId/messages: `[param('roomId').isInt({ min: 1 }).withMessage('Ungueltige Raum-ID'), body('content').optional().trim(), handleValidationErrors]`

**notifications.js:**
- POST /device-token: `[body('token').notEmpty().withMessage('Push-Token ist erforderlich'), body('platform').isIn(['ios', 'android', 'web']).withMessage('Ungueltige Plattform'), handleValidationErrors]`
- DELETE /device-token: `[body('device_id').notEmpty().withMessage('Geraete-ID ist erforderlich'), body('platform').notEmpty().withMessage('Plattform ist erforderlich'), handleValidationErrors]`

**settings.js:**
- PUT /: `[body('target_gottesdienst').optional().isInt({ min: 0 }).withMessage('Zielpunkte muessen eine nicht-negative Ganzzahl sein'), body('target_gemeinde').optional().isInt({ min: 0 }).withMessage('Zielpunkte muessen eine nicht-negative Ganzzahl sein'), handleValidationErrors]`

**badges.js, jahrgaenge.js, categories.js, levels.js, users.js, organizations.js, roles.js:**
Fuer jeden POST/PUT-Endpoint ein passendes Validierungs-Array. Typisches Muster:
- POST / (create): `[commonValidations.name, handleValidationErrors]` (+ Typ-spezifische Felder)
- PUT /:id (update): `[param('id').isInt({ min: 1 }).withMessage('Ungueltige ID'), commonValidations.name, handleValidationErrors]`
- DELETE /:id: `[param('id').isInt({ min: 1 }).withMessage('Ungueltige ID'), handleValidationErrors]`

**WICHTIG:**
- Validierungs-Array IMMER als Middleware zwischen Auth-Middleware und Route-Handler platzieren
- Reihenfolge: `router.post('/', rbacVerifier, requireAdmin, validateArray, handler)`
- `handleValidationErrors` IMMER als letztes Element im Array
- Alle .withMessage()-Texte auf Deutsch
- Bestehende manuelle Validierung (`if (!name) return...`) als Fallback belassen -- nicht entfernen
  </action>
  <verify>
    <automated>cd /Users/simonluthe/Documents/Konfipoints/backend && for f in routes/*.js; do count=$(grep -c "handleValidationErrors" "$f" 2>/dev/null || echo 0); echo "$f: $count"; done</automated>
  </verify>
  <done>Jedes Route-File hat mindestens 1 handleValidationErrors-Verwendung. Die wichtigsten Endpoints (auth/login, auth/register, activities CRUD, konfi-management CRUD, events CRUD, chat messages) haben express-validator Validierungsregeln. Alle Fehlermeldungen sind auf Deutsch und feld-spezifisch.</done>
</task>

<task type="auto">
  <name>Task 3: 429-Rate-Limit-Interceptor im Frontend implementieren</name>
  <files>frontend/src/services/api.ts</files>
  <action>
Den bestehenden axios-Response-Interceptor in `frontend/src/services/api.ts` erweitern um 429-Responses abzufangen.

Der bestehende Interceptor (Zeile 22-37) behandelt nur 401. Erweitern um 429:

```typescript
// Handle auth errors and rate limiting
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Don't redirect during login attempts
      const isLoginRequest = error.config?.url?.includes('/login');
      if (!isLoginRequest) {
        // Token expired or invalid
        localStorage.removeItem('konfi_token');
        localStorage.removeItem('konfi_user');
        window.location.href = '/';
      }
    }

    // Rate-Limit: Benutzerfreundliche Meldung bereitstellen
    if (error.response?.status === 429) {
      const retryAfter = error.response.headers['retry-after'];
      const minutes = retryAfter ? Math.ceil(parseInt(retryAfter) / 60) : 15;
      // Deutsche Meldung per User-Decision
      error.rateLimitMessage = `Zu viele Versuche. Bitte warte ${minutes} Minuten.`;
      // Falls Backend bereits eine Message hat, diese bevorzugen
      if (error.response.data?.error) {
        error.rateLimitMessage = error.response.data.error;
      }
    }

    return Promise.reject(error);
  }
);
```

Das `error.rateLimitMessage` Property kann von jeder Komponente gelesen werden die einen API-Call macht. Beispiel-Verwendung in einer Komponente:

```typescript
try {
  await api.post('/auth/login', data);
} catch (err: any) {
  if (err.rateLimitMessage) {
    setError(err.rateLimitMessage); // Inline-Fehler im Formular
  } else {
    setError('Anmeldung fehlgeschlagen');
  }
}
```

Per User-Decision: Inline-Fehler im Formular anzeigen (z.B. unter dem Login-Button), kein Toast oder Modal. Die Komponenten muessen das rateLimitMessage Property pruefen -- das ist KEIN globaler Toast.

HINWEIS: Die tatsaechliche Anzeige des Inline-Fehlers in den einzelnen Formularen (Login, Chat, etc.) ist eine UI-Aenderung die NICHT Teil dieses Plans ist. Dieser Plan stellt nur den Mechanismus bereit (rateLimitMessage auf dem Error-Objekt). Die UI-Integration erfolgt bei Bedarf in spaeteren Phasen.
  </action>
  <verify>
    <automated>cd /Users/simonluthe/Documents/Konfipoints/frontend && grep -n "429\|rateLimitMessage" src/services/api.ts</automated>
  </verify>
  <done>api.ts hat einen 429-Interceptor der rateLimitMessage auf dem Error-Objekt setzt. Die Meldung ist auf Deutsch mit Wartezeit-Hinweis. Backend-Meldung wird bevorzugt falls vorhanden.</done>
</task>

</tasks>

<verification>
1. `cd backend && node -e "const v = require('./middleware/validation'); console.log(Object.keys(v));"` -- zeigt alle Exports
2. `grep -l "handleValidationErrors" backend/routes/*.js | wc -l` -- sollte >= 10 sein (alle Route-Files mit POST/PUT)
3. `grep -c "express-validator" backend/routes/auth.js` -- mindestens 1
4. `grep "rateLimitMessage" frontend/src/services/api.ts` -- mindestens 2 Treffer
5. `grep "429" frontend/src/services/api.ts` -- mindestens 1 Treffer
6. `cd backend && node -e "require('express-validator')"` -- kein Fehler (bereits in Plan 01 installiert)
</verification>

<success_criteria>
- express-validator ist auf allen Route-Files mit POST/PUT-Endpoints als Middleware aktiv
- Alle Validierungsmeldungen sind auf Deutsch und feld-spezifisch
- middleware/validation.js hat wiederverwendbare Validierungsbausteine (commonValidations)
- Frontend api.ts faengt 429 ab und setzt rateLimitMessage mit deutschem Text und Wartezeit
- Bestehende manuelle Validierung bleibt als Fallback erhalten
- Keine funktionale Regression -- alle bestehenden Endpoints funktionieren weiterhin
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-hardening/01-03-SUMMARY.md`
</output>
