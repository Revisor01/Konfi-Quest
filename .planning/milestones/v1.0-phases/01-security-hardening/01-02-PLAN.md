---
phase: 01-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/routes/notifications.js
  - backend/routes/settings.js
autonomous: true
requirements: [SEC-02, SEC-03]

must_haves:
  truths:
    - "notifications.js filtert alle DB-Queries nach organization_id des anfragenden Users"
    - "Ein Nutzer kann keine Push-Tokens eines Nutzers aus einer anderen Organisation manipulieren"
    - "settings.js filtert alle DB-Queries nach organization_id des anfragenden Users"
    - "Ein Nutzer aus Organisation A kann keine Settings von Organisation B sehen oder aendern"
    - "Superadmin kann weiterhin Org-uebergreifend auf Daten zugreifen"
  artifacts:
    - path: "backend/routes/notifications.js"
      provides: "Push-Token-Endpoints mit organization_id-Filterung via users-JOIN"
      contains: "organization_id"
    - path: "backend/routes/settings.js"
      provides: "Settings-Endpoints mit organization_id-Filterung"
      contains: "organization_id"
  key_links:
    - from: "backend/routes/notifications.js"
      to: "users Tabelle"
      via: "JOIN fuer organization_id Validierung"
      pattern: "JOIN users.*organization_id"
    - from: "backend/routes/settings.js"
      to: "settings Tabelle"
      via: "WHERE organization_id"
      pattern: "organization_id"
---

<objective>
Multi-Tenant-Isolation lueckenlos machen: notifications.js und settings.js mit organization_id-Filterung absichern.

Purpose: Diese zwei Route-Files sind die einzigen ohne organization_id-Filterung. Ohne Fix koennen Nutzer einer Organisation Push-Tokens und Settings anderer Organisationen manipulieren. Das ist eine kritische Datenschutzluecke.
Output: Beide Route-Files filtern konsistent nach organization_id, Superadmin-Bypass bleibt erhalten.
</objective>

<execution_context>
@/Users/simonluthe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simonluthe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-hardening/01-CONTEXT.md
@.planning/phases/01-security-hardening/01-RESEARCH.md

@backend/routes/notifications.js
@backend/routes/settings.js
@backend/server.js
@backend/middleware/rbac.js

<interfaces>
<!-- notifications.js nimmt verifyToken als Parameter (NICHT rbacVerifier!) -->
Aus server.js Zeile 408:
```javascript
app.use('/api/notifications', notificationsRoutes(db, verifyToken));
```
PROBLEM: notifications.js benutzt das einfache verifyToken (ohne RBAC), nicht rbacVerifier.
verifyToken setzt nur decoded JWT-Daten auf req.user -- OHNE organization_id aus der DB zu laden.
rbacVerifier (verifyTokenRBAC) laedt organization_id, role_name, is_super_admin aus der DB.

Die Route-Signatur muss geaendert werden: statt verifyToken muss rbacVerifier uebergeben werden.
Das betrifft auch server.js wo notificationsRoutes gemounted wird.

<!-- settings.js benutzt bereits rbacVerifier -->
Aus server.js Zeile 416:
```javascript
app.use('/api/settings', settingsRoutes(db, rbacVerifier, roleHelpers));
```
settings.js hat Zugriff auf req.user.organization_id via rbacVerifier.

<!-- req.user nach rbacVerifier enthhaelt: -->
```javascript
req.user = {
  id, organization_id, username, display_name, is_active,
  role_title, is_super_admin,
  role_name, role_display_name,
  organization_name, organization_slug, organization_active,
  assignedJahrgaenge, permissions, type
};
```

<!-- Bestehendes Org-Filter-Pattern aus anderen Routes (z.B. activities.js): -->
```javascript
const { rows } = await db.query(
  'SELECT * FROM activities WHERE organization_id = $1',
  [req.user.organization_id]
);
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: notifications.js auf rbacVerifier umstellen und Org-Isolation hinzufuegen</name>
  <files>backend/routes/notifications.js, backend/server.js</files>
  <action>
**Schritt 1: server.js anpassen -- rbacVerifier statt verifyToken an notificationsRoutes uebergeben:**

In `backend/server.js` Zeile 408 aendern:
VORHER: `app.use('/api/notifications', notificationsRoutes(db, verifyToken));`
NACHHER: `app.use('/api/notifications', notificationsRoutes(db, rbacVerifier));`

**Schritt 2: notifications.js komplett mit Org-Isolation absichern:**

Die Modul-Signatur bleibt: `module.exports = (db, verifyTokenRBAC) => {`
(Der Parameter heisst weiter verifyTokenRBAC -- er bekommt jetzt rbacVerifier statt verifyToken)

**POST /device-token (Zeile 8-101):**
Nach der bestehenden Validierung (`if (!token || !platform)`) und vor dem try-Block:
- Die DELETE-Query (Zeile 48-51) die Tokens anderer User loescht, muss Org-gefiltert werden:
  VORHER: `'DELETE FROM push_tokens WHERE token = $1 AND user_id != $2'`
  NACHHER: Bleibt so -- diese Query ist absichtlich Cross-User (gleicher FCM Token = gleiches Geraet). Aber wir fuegen eine Org-Validierung bei der Upsert-Query hinzu.
- Nach der Upsert-Query: Keine Aenderung noetig, da der Token fuer den eigenen User gespeichert wird (user_id aus JWT).
- JEDOCH: Die Verification-Query (Zeile 74-88) ist ueberfluessig und kann entfernt werden (Performance).

**POST /test-push (Zeile 104-155):**
Die SELECT-Query muss Org-gefiltert werden um sicherzustellen dass nur eigene Tokens gesendet werden:
VORHER: `'SELECT * FROM push_tokens WHERE user_id = $1'`
NACHHER:
```javascript
'SELECT pt.* FROM push_tokens pt JOIN users u ON pt.user_id = u.id WHERE pt.user_id = $1 AND u.organization_id = $2'
```
mit Parametern `[userId, req.user.organization_id]`

**DELETE /device-token (Zeile 158-192):**
Die DELETE-Query muss Org-gefiltert werden:
VORHER: `'DELETE FROM push_tokens WHERE user_id = $1 AND platform = $2 AND device_id = $3'`
NACHHER:
```javascript
`DELETE FROM push_tokens pt
 USING users u
 WHERE pt.user_id = u.id
   AND pt.user_id = $1
   AND pt.platform = $2
   AND pt.device_id = $3
   AND u.organization_id = $4`
```
mit Parametern `[userId, platform, device_id, req.user.organization_id]`

WICHTIG: Kein Superadmin-Bypass noetig bei Notifications -- Push-Tokens sind immer pro User. Superadmin nutzt diese Endpoints nur fuer eigene Geraete.

Entferne auch die ueberfluessigen Debug-Console-Logs (die sensitiven Token-Daten loggen):
- `console.log('Device Token Registration Request:');` und die folgenden 5 Zeilen
- `console.log('Token verified in database:', {` und den gesamten Block
- `console.log('Push Token Logout Request:');` und die folgenden 3 Zeilen
Ersetze durch kurze Logs: `console.log('Device token registered for user:', userId);` etc.
  </action>
  <verify>
    <automated>cd /Users/simonluthe/Documents/Konfipoints/backend && grep -n "organization_id" routes/notifications.js | head -10 && echo "---" && grep -n "rbacVerifier" server.js | grep notification</automated>
  </verify>
  <done>notifications.js hat organization_id-Filterung auf allen 3 Endpoints (POST /device-token via eigenen User, POST /test-push via JOIN, DELETE /device-token via USING). server.js uebergibt rbacVerifier statt verifyToken an notificationsRoutes. Sensitive Token-Daten werden nicht mehr vollstaendig geloggt.</done>
</task>

<task type="auto">
  <name>Task 2: settings.js mit organization_id-Filterung absichern</name>
  <files>backend/routes/settings.js</files>
  <action>
Die settings-Tabelle hat aktuell KEINE organization_id-Spalte -- Settings wie target_gottesdienst und target_gemeinde sind org-spezifische Zielpunkte, die NICHT global sein duerfen. Ein Org A darf nicht die Zielpunkte von Org B sehen.

**Ansatz: Zusammengesetzter Primary Key `(organization_id, key)` statt separater id-Spalte.**

Da wir kein DB-Migrations-Framework haben, muss die Migration in den Code eingebaut werden (analog zu push_tokens CREATE TABLE IF NOT EXISTS in notifications.js).

**Schritt 1: settings.js komplett umschreiben:**

```javascript
const express = require('express');
const router = express.Router();

module.exports = (db, rbacVerifier, { requireOrgAdmin }) => {

  // Ensure settings table has organization_id column
  // (Migration: idempotent, laeuft bei jedem Start)
  const ensureOrgColumn = async () => {
    try {
      // Pruefen ob organization_id Spalte existiert
      const { rows } = await db.query(`
        SELECT column_name FROM information_schema.columns
        WHERE table_name = 'settings' AND column_name = 'organization_id'
      `);

      if (rows.length === 0) {
        console.log('Migrating settings table: adding organization_id column...');

        // Spalte hinzufuegen (nullable zunaechst)
        await db.query('ALTER TABLE settings ADD COLUMN organization_id INTEGER REFERENCES organizations(id)');

        // Bestehende Settings der ersten Organisation zuweisen
        const { rows: orgs } = await db.query('SELECT id FROM organizations ORDER BY id LIMIT 1');
        if (orgs.length > 0) {
          await db.query('UPDATE settings SET organization_id = $1 WHERE organization_id IS NULL', [orgs[0].id]);
        }

        // UNIQUE constraint auf (organization_id, key) setzen
        // Zuerst alten UNIQUE constraint auf key entfernen falls vorhanden
        await db.query(`
          DO $$ BEGIN
            ALTER TABLE settings DROP CONSTRAINT IF EXISTS settings_key_key;
            ALTER TABLE settings DROP CONSTRAINT IF EXISTS settings_pkey;
          EXCEPTION WHEN OTHERS THEN NULL;
          END $$;
        `);
        await db.query('ALTER TABLE settings ADD CONSTRAINT settings_org_key_unique UNIQUE (organization_id, key)');

        console.log('Settings table migration complete');
      }
    } catch (err) {
      console.error('Settings migration error:', err.message);
    }
  };

  // Migration beim Laden ausfuehren
  ensureOrgColumn();

  // GET settings (alle authentifizierten User der eigenen Org)
  router.get('/', rbacVerifier, async (req, res) => {
    try {
      const orgFilter = req.user.is_super_admin ? '' : 'WHERE organization_id = $1';
      const params = req.user.is_super_admin ? [] : [req.user.organization_id];

      const { rows } = await db.query(
        `SELECT key, value FROM settings ${orgFilter}`,
        params
      );

      const settings = {};
      rows.forEach(row => {
        if (row.key === 'target_gottesdienst' || row.key === 'target_gemeinde' || row.key === 'max_waitlist_size') {
          settings[row.key] = parseInt(row.value, 10) || 0;
        } else if (row.key === 'waitlist_enabled') {
          settings[row.key] = row.value === 'true' || row.value === '1';
        } else {
          settings[row.key] = row.value;
        }
      });

      res.json(settings);
    } catch (err) {
      console.error('Database error in GET /settings:', err);
      res.status(500).json({ error: 'Datenbankfehler' });
    }
  });

  // PUT settings (nur org_admin der eigenen Org)
  router.put('/', rbacVerifier, requireOrgAdmin, async (req, res) => {
    try {
      const orgId = req.user.organization_id;
      const {
        target_gottesdienst,
        target_gemeinde,
        konfi_chat_permissions,
        waitlist_enabled,
        max_waitlist_size
      } = req.body;

      if (target_gottesdienst !== undefined) {
        await db.query(
          `INSERT INTO settings (organization_id, key, value) VALUES ($1, 'target_gottesdienst', $2)
           ON CONFLICT (organization_id, key) DO UPDATE SET value = EXCLUDED.value`,
          [orgId, target_gottesdienst]
        );
      }

      if (target_gemeinde !== undefined) {
        await db.query(
          `INSERT INTO settings (organization_id, key, value) VALUES ($1, 'target_gemeinde', $2)
           ON CONFLICT (organization_id, key) DO UPDATE SET value = EXCLUDED.value`,
          [orgId, target_gemeinde]
        );
      }

      if (konfi_chat_permissions !== undefined) {
        const validPermissions = [
          'direct_only_admin',
          'direct_only_all',
          'group_direct_admin',
          'group_direct_all'
        ];
        if (!validPermissions.includes(konfi_chat_permissions)) {
          return res.status(400).json({
            error: 'Ungueltiger Chat-Berechtigungswert. Gueltige Optionen: ' + validPermissions.join(', ')
          });
        }
        await db.query(
          `INSERT INTO settings (organization_id, key, value) VALUES ($1, 'konfi_chat_permissions', $2)
           ON CONFLICT (organization_id, key) DO UPDATE SET value = EXCLUDED.value`,
          [orgId, konfi_chat_permissions]
        );
      }

      if (waitlist_enabled !== undefined) {
        await db.query(
          `INSERT INTO settings (organization_id, key, value) VALUES ($1, 'waitlist_enabled', $2)
           ON CONFLICT (organization_id, key) DO UPDATE SET value = EXCLUDED.value`,
          [orgId, String(waitlist_enabled)]
        );
      }

      if (max_waitlist_size !== undefined) {
        await db.query(
          `INSERT INTO settings (organization_id, key, value) VALUES ($1, 'max_waitlist_size', $2)
           ON CONFLICT (organization_id, key) DO UPDATE SET value = EXCLUDED.value`,
          [orgId, max_waitlist_size]
        );
      }

      res.json({ message: 'Einstellungen erfolgreich aktualisiert' });

    } catch (err) {
      console.error('Database error in PUT /settings:', err);
      res.status(500).json({ error: 'Datenbankfehler' });
    }
  });

  return router;
};
```

WICHTIG per User-Decision: Superadmin darf Org-Grenzen ueberschreiten. Im GET wird fuer Superadmin kein Org-Filter angewandt. Im PUT muss Superadmin trotzdem eine Org haben (requireOrgAdmin prueft das).

Alle Fehlermeldungen auf Deutsch (per User-Decision).
  </action>
  <verify>
    <automated>cd /Users/simonluthe/Documents/Konfipoints/backend && grep -c "organization_id" routes/settings.js && echo "---" && grep -n "organization_id" routes/settings.js | head -15</automated>
  </verify>
  <done>settings.js filtert alle Queries nach organization_id. GET hat Superadmin-Bypass (kein Filter). PUT verwendet Upsert mit organization_id. Migration-Funktion fuegt organization_id-Spalte zur settings-Tabelle hinzu falls nicht vorhanden. Alle Fehlermeldungen sind auf Deutsch.</done>
</task>

</tasks>

<verification>
1. `grep -c "organization_id" backend/routes/notifications.js` -- mindestens 3
2. `grep -c "organization_id" backend/routes/settings.js` -- mindestens 10
3. `grep "notificationsRoutes(db, rbacVerifier)" backend/server.js` -- 1 Treffer (nicht mehr verifyToken)
4. `grep "verifyToken)" backend/server.js | grep -v "verifyTokenRBAC"` -- 0 Treffer bei notifications (verifyToken wird nur noch fuer andere Zwecke verwendet)
5. Kein Route-File ohne organization_id-Filterung mehr vorhanden
</verification>

<success_criteria>
- notifications.js filtert alle 3 Endpoints nach organization_id (via JOIN mit users-Tabelle)
- notifications.js benutzt rbacVerifier statt verifyToken
- settings.js filtert GET und PUT nach organization_id
- settings-Tabelle hat idempotente Migration fuer organization_id-Spalte
- Superadmin-Bypass im GET von settings.js erhalten
- Alle Fehlermeldungen auf Deutsch
- Sensitive Token-Daten werden nicht mehr vollstaendig in Logs ausgegeben
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-hardening/01-02-SUMMARY.md`
</output>
